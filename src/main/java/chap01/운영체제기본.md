# 운영체제 기본

## Process & Thread


### `Process`

- 운영체제에 의해 파일 시스템에 설치되어 있는 파일을 프로그램이라 칭한다
- 프로세스는 프로그램의 실제 실행을 의미하며 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태이다
- 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위이다

![image](https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/042f1054-92a9-4466-99d4-fbac5734653a)

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap의 형식으로 할당해 준다
- 독립된 메모리 영역을 할당해 주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없고 IPC 나 공유메모리 등의 통신기법들을 사용해서 프로세스 간 통신해야 한다


![image](https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/2d7d8996-a584-4db4-a2b5-530d6214f64d)

### `Thread`

- 스레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행단위 또는 흐름의 단위로서 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다
- 프로세스 내에서 각 필요한 Stack만 할당받고 Code, Data, Heap 영역은 공유해서 각 스레드가 공유한다. 
- 스레드 간 메모리 스택 영역에 접근 할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게 되어 독립적인 함수 호출이 가능해 진다


![image](https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/520db0b7-ad25-49b2-bc0b-3a8ae58dbddd)


- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위를 의미한다
- 스케줄러의 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU 에 할당된다
- 스레드 간 선점이 일어날 때 CPU 의 실행 흐름(문맥)이 전환되는 컨텍스트 스위칭이 발생한다 


![image](https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/8e098280-3c62-4cdf-9521-66e05c4f5b1d)


### 기초 정리

`Process`

여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에게 영향을 미치지 않는다. 즉 프로그램 전체의 안전성을 확보할 수 있다

프로세스 간 전환(컨텍스트 스위칭) 시 레지스터, 캐시메모리 초기화 등 무거운 작업으로 인한 시간적인 비용이 많이 발생한다

프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 크다

프로세스 생성 시 독립적으로 메모리가 할당되기 때문에 리소스 비용이 크다

`Thread`

여러 개의 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미치게 된다

프로세스의 메모리 영역을 공유 하기 때문에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용한다

스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다

스레드 간 공유 메모리 영역의 동시 접근으로 인한 동기화 문제가 발생한다 

하나의 스레드에서 오류가 발생할 경우 프로세스 자체가 종료될 수 있다


## Parallel & Concurrent

### 동시성

<img width="947" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/2b31827c-9e4f-4e2d-9078-c6492dce2ca9">

- 동시성은 CPU 가 한번에 많은 일을 처리하는 것에 중점을 둔다. 즉 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 처리한다 
- 동시성은 작업의 처리를 빠르게 하기 위한 목적이 아닌  CPU 를 효율적으로 사용하는 것에 더 중점을 둔다
  - 스레드가 작업을 처리하다 IO 블록에 걸렸을 경우 CPU는 다른 스레드로 전환해서 작업을 진행
- 동시성은 작업에 대한 처리 방식을 어떤식으로 진행할 것인가에 대한 설계적 관점에서 이해해야 한다. 

- 동시성은 작업해야 할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행해야 한다.


### 병렬성

<img width="972" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/e282995c-3042-45a1-b603-5fc9eb1cbe80">

- 병렬성은 CPU 가 동시에 많은 일을 수행하는 것에 중점을 둔다. 즉 CPU 가 놀지 않고 최대한 바쁘게 동작해야 한다
- 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요하다. 한 개의 코어에서는 절대 병렬성이 구현될 수 없다
- 병렬성은 동시성의 하위 개념으로 작업을 여러 Thread로 분리하고, 운영체제는 그 Thread를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것이다
- 동시성이 작업 처리 방식에 대한 설계에 관한 것이라면 병렬성은 하드웨어에서 계층에서 작업 수행 방식에 관한 것이다.
- 병렬성은 작업해야 할 수가 CPU 코어 수 보다 같거나 적을 경우 가장 효율성이 좋다

<img width="1355" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/57125585-de67-483c-bc14-910e5e714ac8">

---

## Context Switch

### Context
- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register 에는 어떤 값이 저장되어 있는지에 대한 정보가 필요하다
- Context 는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 이 정보들은 운영체제가 관리하는 PCB 라고 하는 자료구조의 공간에 저장된다

### PCB (Process Control Block)

- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조이다
- 컨텍스트 스위칭은 CPU가 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있다

![image](https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/226c40e2-a9ae-43df-9da3-780fd54dca4c)

### 프로세스 상태

- 프로세스는 New(생성), 준비(Ready), 실행(Running), Blocked(대기), Exit(종료) 상태를 가진다


<img width="430" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/0a538bcc-dbff-4da1-acd2-62aee7596fcc">

- New : 프로세스를 생성하고 있는 단계로 커널 영역에 PCB가 만들어진 상태
- Ready : 프로세스가 CPU 를 할당받기 위해 기다리고 있는 상태
- Running : 프로세스가 CPU 를 할당받아 명령어를 실행 중인 상태
- Waiting : 프로세스가 I/O 작업 완료 혹은 사건 발생을 기다리는 상태
- Terminated : 프로세스가 종료된 상태

### 컨텍스트 스위칭이 일어나는 조건

- 실행 중인 프로세스에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 프로세스 상태가 running 에서 waiting 상태로 전이된 경우
- Round Robin 스케쥴링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 있는 시간 자원을
 
  모두 사용했을 때 해당 프로세스를 중지하고(ready 상태로 전이) 다른 프로세스를 실행시켜주는 경우

<img width="840" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/30923bbe-cd7b-4817-bc8b-ff7752dab62f">

<img width="1082" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/4cfcae8e-f811-4065-aeb9-4f31fbc8be50">

### 스레드 컨텍스트 스위칭

- `TCB (Thread Control Block)`
  - Thread 상태정보를 저장하는 자료구조이며, PC와 Register Set(CPU 정보), 그리고 PCB를 가리키는 포인터를 가진다
  - 스레드가 하나 생성될 때마다 PCB 내에서 TCB가 생성되며 컨텍스트 스위칭이 일어나면 기존의 스레드 TCB 를 저장하고 새로운 스레드의 TCB 를 가져와 실행한다 

<img width="833" alt="image" src="https://github.com/saechimdaeki/SpringMSA_Adventure/assets/40031858/fd7d0202-edbe-40e6-bcb7-e92b37f9d5c9">

### 프로세스 vs 스레드

- 프로세스는 컨텍스트 스위칭 할 때 메모리 주소 관련 여러가지 처리(CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정 등..) 를 하기 때문에 오버헤드가 크다
- 스레드는 프로세스 내 메모리를 공유하기 때문에 메모리 주소 관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아서 컨텍스트 스위칭이 빠르다
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 어플리케이션의 성능이 저하될 수 있다 
